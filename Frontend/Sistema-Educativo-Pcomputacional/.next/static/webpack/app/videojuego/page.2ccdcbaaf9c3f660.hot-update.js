"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/videojuego/page",{

/***/ "(app-pages-browser)/./src/MapsGenerator.tsx":
/*!*******************************!*\
  !*** ./src/MapsGenerator.tsx ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _utils_generarSiguienteNumeroValido__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/generarSiguienteNumeroValido */ \"(app-pages-browser)/./src/utils/generarSiguienteNumeroValido.ts\");\n\n/* Bitacora de Luis (Nota número 1 para mi amorcito): Empecé a comentar las secciones de código que he hecho para explicarte que \r\n    voy haciendo mi amor precioso, así vas entendiendo que es lo que busque lograr con cada implementación y tengas una base para explorar\r\n    todas las funciones del código.\r\n    \r\n    La función \"generarEsquemaMapa() se encarga de leer las representaciones del mundo generadas por Tiled (en formato JSON) para imprimir ese mapa\r\n    en la pantalla. Estos mapas contienen propiedades importantes (a las que puedes acceder con punto al ser objetos, ejemplo: world.layer.data), entre ellas\r\n    las más importante es la propiedad \"layers\" que contiene todas las capas de ese mundo, así mismo, cada capa tiene un atributo \"data\" que contiene el ID \r\n    de cada fracción de imagen que se genera cuando cargamos el conjunto de patrones en Tiled.\r\n\r\n    \r\n    */ const TILED_WIDTH_NUMBER = 20;\nconst TILED_HEIGTH_NUMBER = 15;\nconst SCREEN_RESOLUTION_X = window.innerWidth;\nconst SCREEN_RESOLUTION_Y = window.innerHeight;\nconst TILED_MAP__WIDTH_NUMBER = 21;\nconst TILED_MAP_HEIGHT_NUMBER = 16;\nconst generarEsquemaMapa = async (contextoKaplay, configuracionMapa, urlMapa, informacionMapa //Contiene en orden todas las imagenes que se utilizaron en cada capa para generar el mundo.\n)=>{\n    return fetch(urlMapa).then((res)=>res.json()).then((worldJson)=>{\n        console.log(\"LLAMANDO A LA FUNCION GENERAR MAPA\");\n        console.log(contextoKaplay.get(\"*\"));\n        //console.log(`${configuracionMapa.nameFolder}/${configuracionMapa.nameFile}`)\n        contextoKaplay.loadSprite(\"mundo\", \"\".concat(configuracionMapa.nameFolder, \"/\").concat(configuracionMapa.nameFile), {\n            sliceX: 1,\n            sliceY: 1\n        });\n        contextoKaplay.onDraw(()=>{\n            contextoKaplay.drawSprite({\n                sprite: \"mundo\",\n                width: window.innerWidth,\n                height: window.innerHeight\n            });\n        });\n        //Extraemos los arreglos que contienen el firtsgid (Posición donde comienzan cada una de las imagenes de cada capa)\n        const tilesetOrder = informacionMapa;\n        console.log(tilesetOrder);\n        //cargamos todas las texturas que seran usadas para generar el mapa en orden\n        const spritesCargados = [];\n        informacionMapa.forEach((informacionNivel, index)=>{\n            spritesCargados.push(contextoKaplay.loadSprite(\"tiles-\".concat(index + 1), informacionNivel.urlTextura, {\n                sliceX: informacionNivel.dimensionTexturasX,\n                sliceY: informacionNivel.dimensionTexturasY\n            }));\n        });\n        const anchoCuadrado = window.innerWidth / worldJson.width;\n        const altoCuadrado = window.innerHeight / worldJson.height;\n        const tileMap = [\n            {}\n        ];\n        const valoresProhibidos = [\n            39,\n            48,\n            49,\n            50,\n            51,\n            52,\n            53,\n            54,\n            55,\n            56,\n            57\n        ];\n        const mapaGenerado = worldJson === null || worldJson === void 0 ? void 0 : worldJson.layers;\n        //Luego para cada CAPA que contiene números que no pueden ser procesados por el generador de niveles\n        //Es necesario que realizacemos una reasignación con un caracter ASCII, tomando en cuenta que hay caracteres que \n        //No pueden ser procesados como una cadena (Valores Prohibidos)\n        mapaGenerado.forEach((layer, numeroLayer)=>{\n            //Para cada capa inicializamos un contador que contiene el código ASCII del \"$\" para reemplazarlo en el caso de que el número\n            //extraido sea mayor a 9\n            let contador = 36;\n            if (layer.type === \"tilelayer\") {\n                //Luego por cada uno de los números que representan una capa realizamos lo siguiente:\n                layer.data.forEach((tileNumber, index)=>{\n                    //Validamos que el TileMap el cual contiene una relación llave valor con el caracter \n                    //y su equivalente en la capa, por ejemplo $: 36, esté inicializado.\n                    if (!(numeroLayer >= 0 && numeroLayer < tileMap.length)) {\n                        tileMap.push({});\n                    }\n                    //Si el \"Tilemap\" en la capa actual no ha mapeado el número\n                    if (Object.values(tileMap[numeroLayer]).includes(tileNumber) === false) {\n                        //Validmos si es un número de dos dígitos y en caso de que lo sea, debemos validar el\n                        //ultimo valor posible del contador.\n                        contador = (0,_utils_generarSiguienteNumeroValido__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(contador, valoresProhibidos);\n                        //Una vez validado, si el número a evaluar es de dos digitos y el contador está entre\n                        //los numeros validos\n                        if (tileNumber.toString().length > 1 && contador >= 33 && contador <= 165) {\n                            //Al mapeo de la capa evaluada le asignamos una correspondencia entre el valor ASCCI y el numero\n                            tileMap[numeroLayer][String.fromCharCode(contador)] = tileNumber;\n                            //Actualizamos el mapa de la misma posicion con el nuevo caracter\n                            worldJson.layers[numeroLayer].data[index] = String.fromCharCode(contador);\n                            //Avanzamos el contador para tomar el nuevo valor ASCII\n                            contador++;\n                        } else if (contador > 165) {\n                            //En caso de que el contador haya superado el límite de asignaciones\n                            throw new Error(\"La cantidad de cuadros a superado el limite establecido\");\n                        } else {\n                            //Si el mapeo realizado es de un número de un sólo digito entonces asignamos directamente ese numero \n                            tileMap[numeroLayer][tileNumber.toString()] = tileNumber;\n                        }\n                    } else {\n                        var _Object_entries_find;\n                        //En la caso de extraer un número que ya ha sido mapeado y ya tiene asignado un valor ASCII\n                        //Buscamos la llave a la que le corresponde ese valor\n                        //Y actualizamos el mapa con ese caracter encontrado.\n                        const keyEncontrada = (_Object_entries_find = Object.entries(tileMap[numeroLayer]).find((param)=>{\n                            let [_, value] = param;\n                            return value === tileNumber;\n                        })) === null || _Object_entries_find === void 0 ? void 0 : _Object_entries_find[0];\n                        worldJson.layers[numeroLayer].data[index] = keyEncontrada;\n                    }\n                });\n            }\n            //let tamañoCuadro = window.innerWidth / 20\n            //let cuadroPosicion = zonaColision.x / 32\n            let proporcionX = window.innerWidth / (32 * TILED_MAP__WIDTH_NUMBER);\n            let proporcionY = window.innerHeight / (32 * TILED_HEIGTH_NUMBER);\n            if (layer.type === \"objectgroup\" && layer.name === \"colisiones\") {\n                layer.objects.forEach((zonaColision, numeroColision)=>{\n                    //if(numeroColision === 4){\n                    // Zona de caid\n                    console.log(zonaColision.width);\n                    let caida_ = contextoKaplay.add([\n                        contextoKaplay.pos(zonaColision.x / 32 * (window.innerWidth / 20), Math.floor(zonaColision.y / 32 * (window.innerHeight / 15))),\n                        contextoKaplay.scale(1),\n                        contextoKaplay.body({\n                            isStatic: true\n                        }),\n                        contextoKaplay.area({\n                            shape: new contextoKaplay.Rect(contextoKaplay.vec2(0.0), zonaColision.width / 32 * (window.innerWidth / 20), zonaColision.height * proporcionY) // Rectángulo más pequeño\n                        }),\n                        {\n                            width: zonaColision.width * proporcionX,\n                            height: zonaColision.height * proporcionY\n                        },\n                        //`square-${numeroColision}`,\n                        \"square-colision\"\n                    ]);\n                //}\n                });\n            }\n            if (layer.type === \"objectgroup\" && layer.name === \"player\") {\n                // Jugador\n                const player = contextoKaplay.add([\n                    contextoKaplay.pos(layer.objects[0].x / 32 * (window.innerWidth / 20), layer.objects[0].y / 32 * (window.innerHeight / 15)),\n                    contextoKaplay.sprite(\"knight\"),\n                    contextoKaplay.scale(1),\n                    contextoKaplay.health(3),\n                    contextoKaplay.area(),\n                    \"player\",\n                    {\n                        z: 1\n                    } // Asegura que el jugador esté en una capa superior\n                ]);\n                player.tag(\"player\");\n                console.log(player);\n                console.log(contextoKaplay.get(\"player\"));\n            }\n            if (layer.type === \"objectgroup\" && layer.name === \"enemy\") {\n                // Jugador\n                // Enemigo\n                const enemy = contextoKaplay.add([\n                    contextoKaplay.pos(layer.objects[0].x / 32 * (window.innerWidth / 20), layer.objects[0].y / 32 * (window.innerHeight / 15)),\n                    contextoKaplay.sprite(\"enemy\"),\n                    contextoKaplay.scale(0.8),\n                    contextoKaplay.area(),\n                    contextoKaplay.body(),\n                    \"enemy\",\n                    {\n                        z: 1\n                    } // Asegura que el jugador esté en una capa superior\n                ]);\n                enemy.tag(\"enemy\");\n            }\n        });\n        const tileMapping = [];\n        //Una vez realizada la asignación entre valores ASCII y valores númericos del mapa\n        //Es necesario asignar a un SPRITE a cada uno de esos valores, por lo que para\n        //lograrlo hacemos lo siguiente:\n        tileMap.forEach((layer, numeroLayer)=>{\n            //Para cada valor ASCII de la capa que se está evaluado hacemos lo siguiente\n            Object.keys(layer).forEach((key, index)=>{\n                //Si la capa que estamos extrayendo es la primera, extraemos el valor numerico asociado al codigo ASCII o \"key\"\n                //De lo contrario, si es una capa superior, debemos restar el punto de origen de las imagenes SPRITE usadas para\n                //hallar los frames originales.\n                const frame = numeroLayer === 0 ? layer[key] : layer[key] !== 0 && layer[key] !== \"0\" ? layer[key] - tilesetOrder[numeroLayer].firstgid + 1 : 0; // Obtener el frame correcto del tileMap\n                // Asegurar que tileMapping[index] existe como un objeto antes de asignar valores\n                if (!tileMapping[numeroLayer]) {\n                    tileMapping[numeroLayer] = {};\n                }\n                //Si la clave que se está evaluando no es cero, entonces quiere decir que tiene un sprite asociado y no es vacio\n                //Por lo que hacemos lo siguiente\n                if (key !== 0 && key !== \"0\") {\n                    //Al TileMapping (Mapa entre codigo ASCII y el SPRITE le asignamos el frame encontrado (menos una posicion porque TILED empieza en 1))\n                    tileMapping[numeroLayer][key] = ()=>[\n                            contextoKaplay.sprite(\"tiles-\".concat(numeroLayer + 1), {\n                                frame: frame - 1,\n                                width: anchoCuadrado,\n                                height: altoCuadrado\n                            }),\n                            contextoKaplay.scale(1)\n                        ];\n                } else {\n                    //De lo contrario si encuentra un cero, le asignamos una imagen especial transparente para cubrir el espacio vacio\n                    tileMapping[numeroLayer][key] = ()=>[\n                            contextoKaplay.sprite(\"title-0\", {\n                                width: anchoCuadrado,\n                                height: altoCuadrado\n                            })\n                        ];\n                }\n            });\n        });\n    /*\r\n        worldJson.layers.forEach((layer: any, numeroLayer: number) => {\r\n        \r\n          let resultadoMapa = [];\r\n          if (layer.type === \"tilelayer\" ) {\r\n            const { data, width } = layer;\r\n            const mapa = [];\r\n            for (let i = 0; i < width; i++) {\r\n              mapa.push(data.slice(i * width, (i + 1) * width));\r\n            }\r\n  \r\n            const resultadoMapeo = mapa.map((fila: any) =>\r\n              fila.map((cell: any) => cell.toString()).join(\"\")\r\n            );\r\n  \r\n            resultadoMapa = [...resultadoMapeo]\r\n  \r\n          \r\n            contextoKaplay.addLevel(resultadoMapa, {\r\n              tileWidth: anchoCuadrado,\r\n              tileHeight: altoCuadrado,\r\n              pos: configuracionMapa.pos,\r\n              tiles: { ...tileMapping[numeroLayer] },\r\n            })\r\n          }\r\n  \r\n  \r\n          \r\n          \r\n        })\r\n        */ }).catch((error)=>{\n        console.error(error);\n    });\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (generarEsquemaMapa);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9NYXBzR2VuZXJhdG9yLnRzeCIsIm1hcHBpbmdzIjoiOzs7OztBQUVpRjtBQUc3RTs7Ozs7Ozs7OztJQVVBLEdBRUEsTUFBTUMscUJBQTRCO0FBQ2xDLE1BQU1DLHNCQUE2QjtBQVFuQyxNQUFNQyxzQkFBOEJDLE9BQU9DLFVBQVU7QUFDckQsTUFBTUMsc0JBQThCRixPQUFPRyxXQUFXO0FBRXRELE1BQU1DLDBCQUFrQztBQUN4QyxNQUFNQywwQkFBa0M7QUFLeEMsTUFBTUMscUJBQXFCLE9BRTNCQyxnQkFDQUMsbUJBQ0FDLFNBQ0FDLGdCQUFvQyw0RkFBNEY7O0lBR2hJLE9BQU9DLE1BQU1GLFNBQVNHLElBQUksQ0FDeEIsQ0FBQ0MsTUFBUUEsSUFBSUMsSUFBSSxJQUVsQkYsSUFBSSxDQUNILENBQUNHO1FBRUNDLFFBQVFDLEdBQUcsQ0FBQztRQUNaRCxRQUFRQyxHQUFHLENBQUNWLGVBQWVXLEdBQUcsQ0FBQztRQUUvQiw4RUFBOEU7UUFFOUVYLGVBQWVZLFVBQVUsQ0FBQyxTQUFTLEdBQW1DWCxPQUFoQ0Esa0JBQWtCWSxVQUFVLEVBQUMsS0FBOEIsT0FBM0JaLGtCQUFrQmEsUUFBUSxHQUFJO1lBQ2xHQyxRQUFRO1lBQ1JDLFFBQVE7UUFDVjtRQUVBaEIsZUFBZWlCLE1BQU0sQ0FBQztZQUNwQmpCLGVBQWVrQixVQUFVLENBQUM7Z0JBQ3hCQyxRQUFRO2dCQUNSQyxPQUFPM0IsT0FBT0MsVUFBVTtnQkFDeEIyQixRQUFRNUIsT0FBT0csV0FBVztZQUM1QjtRQUNGO1FBSUEsbUhBQW1IO1FBQ25ILE1BQU0wQixlQUFtQm5CO1FBQ3pCTSxRQUFRQyxHQUFHLENBQUNZO1FBRVosNEVBQTRFO1FBQzVFLE1BQU1DLGtCQUF3QyxFQUFFO1FBQ2hEcEIsZ0JBQWdCcUIsT0FBTyxDQUFFLENBQUNDLGtCQUFvQ0M7WUFDMURILGdCQUFnQkksSUFBSSxDQUFDM0IsZUFBZVksVUFBVSxDQUFDLFNBQWlCLE9BQVJjLFFBQU0s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by1QY29tcHV0YWNpb25hbFxcRnJvbnRlbmRcXFNpc3RlbWEtRWR1Y2F0aXZvLVBjb21wdXRhY2lvbmFsXFxzcmNcXE1hcHNHZW5lcmF0b3IudHN4Il0sInNvdXJjZXNDb250ZW50IjpbIlxyXG5pbXBvcnQgeyBBc3NldCwgS0FQTEFZQ3R4LCBTcHJpdGVEYXRhLCBWZWMyIH0gZnJvbSBcImthcGxheVwiO1xyXG5pbXBvcnQgZGV2b2x2ZXJTaWd1aWVudGVOdW1lcm9WYWxpZG8gZnJvbSBcIi4vdXRpbHMvZ2VuZXJhclNpZ3VpZW50ZU51bWVyb1ZhbGlkb1wiO1xyXG5cclxuXHJcbiAgICAvKiBCaXRhY29yYSBkZSBMdWlzIChOb3RhIG7Dum1lcm8gMSBwYXJhIG1pIGFtb3JjaXRvKTogRW1wZWPDqSBhIGNvbWVudGFyIGxhcyBzZWNjaW9uZXMgZGUgY8OzZGlnbyBxdWUgaGUgaGVjaG8gcGFyYSBleHBsaWNhcnRlIHF1ZSBcclxuICAgIHZveSBoYWNpZW5kbyBtaSBhbW9yIHByZWNpb3NvLCBhc8OtIHZhcyBlbnRlbmRpZW5kbyBxdWUgZXMgbG8gcXVlIGJ1c3F1ZSBsb2dyYXIgY29uIGNhZGEgaW1wbGVtZW50YWNpw7NuIHkgdGVuZ2FzIHVuYSBiYXNlIHBhcmEgZXhwbG9yYXJcclxuICAgIHRvZGFzIGxhcyBmdW5jaW9uZXMgZGVsIGPDs2RpZ28uXHJcbiAgICBcclxuICAgIExhIGZ1bmNpw7NuIFwiZ2VuZXJhckVzcXVlbWFNYXBhKCkgc2UgZW5jYXJnYSBkZSBsZWVyIGxhcyByZXByZXNlbnRhY2lvbmVzIGRlbCBtdW5kbyBnZW5lcmFkYXMgcG9yIFRpbGVkIChlbiBmb3JtYXRvIEpTT04pIHBhcmEgaW1wcmltaXIgZXNlIG1hcGFcclxuICAgIGVuIGxhIHBhbnRhbGxhLiBFc3RvcyBtYXBhcyBjb250aWVuZW4gcHJvcGllZGFkZXMgaW1wb3J0YW50ZXMgKGEgbGFzIHF1ZSBwdWVkZXMgYWNjZWRlciBjb24gcHVudG8gYWwgc2VyIG9iamV0b3MsIGVqZW1wbG86IHdvcmxkLmxheWVyLmRhdGEpLCBlbnRyZSBlbGxhc1xyXG4gICAgbGFzIG3DoXMgaW1wb3J0YW50ZSBlcyBsYSBwcm9waWVkYWQgXCJsYXllcnNcIiBxdWUgY29udGllbmUgdG9kYXMgbGFzIGNhcGFzIGRlIGVzZSBtdW5kbywgYXPDrSBtaXNtbywgY2FkYSBjYXBhIHRpZW5lIHVuIGF0cmlidXRvIFwiZGF0YVwiIHF1ZSBjb250aWVuZSBlbCBJRCBcclxuICAgIGRlIGNhZGEgZnJhY2Npw7NuIGRlIGltYWdlbiBxdWUgc2UgZ2VuZXJhIGN1YW5kbyBjYXJnYW1vcyBlbCBjb25qdW50byBkZSBwYXRyb25lcyBlbiBUaWxlZC5cclxuXHJcbiAgICBcclxuICAgICovXHJcblxyXG4gICAgY29uc3QgVElMRURfV0lEVEhfTlVNQkVSOm51bWJlciA9IDIwXHJcbiAgICBjb25zdCBUSUxFRF9IRUlHVEhfTlVNQkVSOm51bWJlciA9IDE1XHJcblxyXG4gICAgaW50ZXJmYWNlIGluZm9ybWFjaW9uTml2ZWwge1xyXG4gICAgICB1cmxUZXh0dXJhOiBzdHJpbmcsXHJcbiAgICAgIGRpbWVuc2lvblRleHR1cmFzWDogbnVtYmVyLFxyXG4gICAgICBkaW1lbnNpb25UZXh0dXJhc1k6IG51bWJlcixcclxuICAgICAgZmlyc3RnaWQ6IG51bWJlclxyXG4gICAgfVxyXG4gICAgY29uc3QgU0NSRUVOX1JFU09MVVRJT05fWDogbnVtYmVyID0gd2luZG93LmlubmVyV2lkdGggXHJcbiAgICBjb25zdCBTQ1JFRU5fUkVTT0xVVElPTl9ZOiBudW1iZXIgPSB3aW5kb3cuaW5uZXJIZWlnaHQgXHJcbiAgICBcclxuICAgIGNvbnN0IFRJTEVEX01BUF9fV0lEVEhfTlVNQkVSOiBudW1iZXIgPSAyMVxyXG4gICAgY29uc3QgVElMRURfTUFQX0hFSUdIVF9OVU1CRVI6IG51bWJlciA9IDE2XHJcbiAgICBcclxuXHJcblxyXG5cclxuICAgIGNvbnN0IGdlbmVyYXJFc3F1ZW1hTWFwYSA9IGFzeW5jIChcclxuICAgICAgXHJcbiAgICBjb250ZXh0b0thcGxheTogS0FQTEFZQ3R4PHt9LG5ldmVyPiwgLy8gY29udGV4dG9LYXBsYXkgZXMgZWwgb2JqZXRvIHF1ZSByZXByZXNlbnRhIHRvZG8gZWwganVlZ28geSBzZSBvYnRpZW5lIGRlIGxhIGZ1bmNpw7NuIFwia2FwbGF5KClcIlxyXG4gICAgY29uZmlndXJhY2lvbk1hcGE6IHsgbmFtZUZvbGRlcjogc3RyaW5nLCBuYW1lRmlsZTogc3RyaW5nLHRpbGVXaWR0aDogbnVtYmVyLHRpbGVIZWlnaHQ6IG51bWJlcixwb3M6IFZlYzIsfSwgLy8gbGEgY29uZmlndXJhY2nDs24gZGVsIG1hcGEgcmVwcmVzZW50YSBsYXMgZGltZW5zaW9uZXMgcXVlIGRlYmUgdGVuZXIgY2FkYSBjdWFkcm8geSBsYSBwb3NpY2nDs24gZGVsIHByaW1lcm8gcGFyYSBlbXBlemFyIGEgZGlidWphclxyXG4gICAgdXJsTWFwYTogc3RyaW5nLCAvL0VzIGxhIFVSTCBlbiBsYSBxdWUgc2UgZW5jdWVudHJhIGxhIGNhcnBldGEgY29uIGxhcyBpbWFnZW5lcyBkZWwgbWFwYSBlbiBmb3JtYXRvIEpTT05cclxuICAgIGluZm9ybWFjaW9uTWFwYTogaW5mb3JtYWNpb25OaXZlbFtdIC8vQ29udGllbmUgZW4gb3JkZW4gdG9kYXMgbGFzIGltYWdlbmVzIHF1ZSBzZSB1dGlsaXphcm9uIGVuIGNhZGEgY2FwYSBwYXJhIGdlbmVyYXIgZWwgbXVuZG8uXHJcbiAgKSA6IFByb21pc2U8YW55PiA9PiB7XHJcbiAgXHJcbiAgICByZXR1cm4gZmV0Y2godXJsTWFwYSkudGhlbihcclxuICAgICAgKHJlcykgPT4gcmVzLmpzb24oKVxyXG4gICAgKVxyXG4gICAgLnRoZW4oXHJcbiAgICAgICh3b3JsZEpzb246YW55KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiTExBTUFORE8gQSBMQSBGVU5DSU9OIEdFTkVSQVIgTUFQQVwiKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGNvbnRleHRvS2FwbGF5LmdldChcIipcIikpXHJcblxyXG4gICAgICAgIC8vY29uc29sZS5sb2coYCR7Y29uZmlndXJhY2lvbk1hcGEubmFtZUZvbGRlcn0vJHtjb25maWd1cmFjaW9uTWFwYS5uYW1lRmlsZX1gKVxyXG5cclxuICAgICAgICBjb250ZXh0b0thcGxheS5sb2FkU3ByaXRlKFwibXVuZG9cIiwgYCR7Y29uZmlndXJhY2lvbk1hcGEubmFtZUZvbGRlcn0vJHtjb25maWd1cmFjaW9uTWFwYS5uYW1lRmlsZX1gLCB7XHJcbiAgICAgICAgICBzbGljZVg6IDEsXHJcbiAgICAgICAgICBzbGljZVk6IDEsXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnRleHRvS2FwbGF5Lm9uRHJhdygoKSA9PiB7XHJcbiAgICAgICAgICBjb250ZXh0b0thcGxheS5kcmF3U3ByaXRlKHtcclxuICAgICAgICAgICAgc3ByaXRlOiBcIm11bmRvXCIsXHJcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHRcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gXHJcblxyXG5cclxuICAgICAgICAvL0V4dHJhZW1vcyBsb3MgYXJyZWdsb3MgcXVlIGNvbnRpZW5lbiBlbCBmaXJ0c2dpZCAoUG9zaWNpw7NuIGRvbmRlIGNvbWllbnphbiBjYWRhIHVuYSBkZSBsYXMgaW1hZ2VuZXMgZGUgY2FkYSBjYXBhKVxyXG4gICAgICAgIGNvbnN0IHRpbGVzZXRPcmRlcjogYW55PSBpbmZvcm1hY2lvbk1hcGFcclxuICAgICAgICBjb25zb2xlLmxvZyh0aWxlc2V0T3JkZXIpXHJcbiAgXHJcbiAgICAgICAgLy9jYXJnYW1vcyB0b2RhcyBsYXMgdGV4dHVyYXMgcXVlIHNlcmFuIHVzYWRhcyBwYXJhIGdlbmVyYXIgZWwgbWFwYSBlbiBvcmRlblxyXG4gICAgICAgIGNvbnN0IHNwcml0ZXNDYXJnYWRvczogIEFzc2V0PFNwcml0ZURhdGE+W10gPSBbXVxyXG4gICAgICAgIGluZm9ybWFjaW9uTWFwYS5mb3JFYWNoKCAoaW5mb3JtYWNpb25OaXZlbDogaW5mb3JtYWNpb25OaXZlbCwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICBzcHJpdGVzQ2FyZ2Fkb3MucHVzaChjb250ZXh0b0thcGxheS5sb2FkU3ByaXRlKGB0aWxlcy0ke2luZGV4KzF9YCwgaW5mb3JtYWNpb25OaXZlbC51cmxUZXh0dXJhLCB7XHJcbiAgICAgICAgICAgICAgc2xpY2VYOiBpbmZvcm1hY2lvbk5pdmVsLmRpbWVuc2lvblRleHR1cmFzWCxcclxuICAgICAgICAgICAgICBzbGljZVk6IGluZm9ybWFjaW9uTml2ZWwuZGltZW5zaW9uVGV4dHVyYXNZLFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgIH0pXHJcbiAgXHJcbiAgICAgICAgY29uc3QgYW5jaG9DdWFkcmFkbzogbnVtYmVyID0gd2luZG93LmlubmVyV2lkdGggLyB3b3JsZEpzb24ud2lkdGhcclxuICAgICAgICBjb25zdCBhbHRvQ3VhZHJhZG86IG51bWJlciA9IHdpbmRvdy5pbm5lckhlaWdodCAvIHdvcmxkSnNvbi5oZWlnaHRcclxuICAgICAgXHJcbiAgICAgICAgY29uc3QgdGlsZU1hcDogeyBba2V5OiBzdHJpbmddIDogbnVtYmVyfVtdID0gW3t9XVxyXG4gIFxyXG4gICAgICAgIGNvbnN0IHZhbG9yZXNQcm9oaWJpZG9zOiBudW1iZXJbXSA9IFszOSw0OCw0OSw1MCw1MSw1Miw1Myw1NCw1NSw1Niw1N11cclxuICBcclxuICAgICAgICBjb25zdCBtYXBhR2VuZXJhZG8gPSB3b3JsZEpzb24/LmxheWVyc1xyXG4gIFxyXG4gICAgICAgIC8vTHVlZ28gcGFyYSBjYWRhIENBUEEgcXVlIGNvbnRpZW5lIG7Dum1lcm9zIHF1ZSBubyBwdWVkZW4gc2VyIHByb2Nlc2Fkb3MgcG9yIGVsIGdlbmVyYWRvciBkZSBuaXZlbGVzXHJcbiAgICAgICAgLy9FcyBuZWNlc2FyaW8gcXVlIHJlYWxpemFjZW1vcyB1bmEgcmVhc2lnbmFjacOzbiBjb24gdW4gY2FyYWN0ZXIgQVNDSUksIHRvbWFuZG8gZW4gY3VlbnRhIHF1ZSBoYXkgY2FyYWN0ZXJlcyBxdWUgXHJcbiAgICAgICAgLy9ObyBwdWVkZW4gc2VyIHByb2Nlc2Fkb3MgY29tbyB1bmEgY2FkZW5hIChWYWxvcmVzIFByb2hpYmlkb3MpXHJcbiAgICAgICAgbWFwYUdlbmVyYWRvLmZvckVhY2goKGxheWVyOmFueSwgbnVtZXJvTGF5ZXI6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgLy9QYXJhIGNhZGEgY2FwYSBpbmljaWFsaXphbW9zIHVuIGNvbnRhZG9yIHF1ZSBjb250aWVuZSBlbCBjw7NkaWdvIEFTQ0lJIGRlbCBcIiRcIiBwYXJhIHJlZW1wbGF6YXJsbyBlbiBlbCBjYXNvIGRlIHF1ZSBlbCBuw7ptZXJvXHJcbiAgICAgICAgICAvL2V4dHJhaWRvIHNlYSBtYXlvciBhIDlcclxuICAgICAgICAgIGxldCBjb250YWRvciA9IDM2O1xyXG4gIFxyXG4gICAgICAgICAgaWYobGF5ZXIudHlwZSA9PT0gXCJ0aWxlbGF5ZXJcIil7XHJcbiAgXHJcbiAgICAgICAgICAgIC8vTHVlZ28gcG9yIGNhZGEgdW5vIGRlIGxvcyBuw7ptZXJvcyBxdWUgcmVwcmVzZW50YW4gdW5hIGNhcGEgcmVhbGl6YW1vcyBsbyBzaWd1aWVudGU6XHJcbiAgICAgICAgICAgIGxheWVyLmRhdGEuZm9yRWFjaCggKHRpbGVOdW1iZXI6IG51bWJlciwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gIFxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIC8vVmFsaWRhbW9zIHF1ZSBlbCBUaWxlTWFwIGVsIGN1YWwgY29udGllbmUgdW5hIHJlbGFjacOzbiBsbGF2ZSB2YWxvciBjb24gZWwgY2FyYWN0ZXIgXHJcbiAgICAgICAgICAgICAgLy95IHN1IGVxdWl2YWxlbnRlIGVuIGxhIGNhcGEsIHBvciBlamVtcGxvICQ6IDM2LCBlc3TDqSBpbmljaWFsaXphZG8uXHJcbiAgICAgICAgICAgICAgaWYgKCEobnVtZXJvTGF5ZXIgPj0gMCAmJiBudW1lcm9MYXllciA8IHRpbGVNYXAubGVuZ3RoKSkge1xyXG4gICAgICAgICAgICAgICAgdGlsZU1hcC5wdXNoKHt9KVxyXG4gICAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgICAvL1NpIGVsIFwiVGlsZW1hcFwiIGVuIGxhIGNhcGEgYWN0dWFsIG5vIGhhIG1hcGVhZG8gZWwgbsO6bWVyb1xyXG4gICAgICAgICAgICAgIGlmKE9iamVjdC52YWx1ZXModGlsZU1hcFtudW1lcm9MYXllcl0pLmluY2x1ZGVzKHRpbGVOdW1iZXIpID09PSBmYWxzZSl7XHJcbiAgXHJcbiAgICAgICAgICAgICAgICAvL1ZhbGlkbW9zIHNpIGVzIHVuIG7Dum1lcm8gZGUgZG9zIGTDrWdpdG9zIHkgZW4gY2FzbyBkZSBxdWUgbG8gc2VhLCBkZWJlbW9zIHZhbGlkYXIgZWxcclxuICAgICAgICAgICAgICAgIC8vdWx0aW1vIHZhbG9yIHBvc2libGUgZGVsIGNvbnRhZG9yLlxyXG4gICAgICAgICAgICAgICAgY29udGFkb3IgPSBkZXZvbHZlclNpZ3VpZW50ZU51bWVyb1ZhbGlkbyhjb250YWRvcix2YWxvcmVzUHJvaGliaWRvcylcclxuICBcclxuICAgICAgICAgICAgICAgIC8vVW5hIHZleiB2YWxpZGFkbywgc2kgZWwgbsO6bWVybyBhIGV2YWx1YXIgZXMgZGUgZG9zIGRpZ2l0b3MgeSBlbCBjb250YWRvciBlc3TDoSBlbnRyZVxyXG4gICAgICAgICAgICAgICAgLy9sb3MgbnVtZXJvcyB2YWxpZG9zXHJcbiAgICAgICAgICAgICAgICBpZih0aWxlTnVtYmVyLnRvU3RyaW5nKCkubGVuZ3RoID4gMSAmJiBjb250YWRvciA+PSAzMyAmJiBjb250YWRvciA8PTE2NSApe1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgICAvL0FsIG1hcGVvIGRlIGxhIGNhcGEgZXZhbHVhZGEgbGUgYXNpZ25hbW9zIHVuYSBjb3JyZXNwb25kZW5jaWEgZW50cmUgZWwgdmFsb3IgQVNDQ0kgeSBlbCBudW1lcm9cclxuICAgICAgICAgICAgICAgICAgKHRpbGVNYXBbbnVtZXJvTGF5ZXJdKVtTdHJpbmcuZnJvbUNoYXJDb2RlKGNvbnRhZG9yKV0gPSB0aWxlTnVtYmVyIGFzIG51bWJlcjtcclxuICBcclxuICAgICAgICAgICAgICAgICAgLy9BY3R1YWxpemFtb3MgZWwgbWFwYSBkZSBsYSBtaXNtYSBwb3NpY2lvbiBjb24gZWwgbnVldm8gY2FyYWN0ZXJcclxuICAgICAgICAgICAgICAgICAgd29ybGRKc29uLmxheWVyc1tudW1lcm9MYXllcl0uZGF0YVtpbmRleF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvbnRhZG9yKTtcclxuICBcclxuICAgICAgICAgICAgICAgICAgLy9BdmFuemFtb3MgZWwgY29udGFkb3IgcGFyYSB0b21hciBlbCBudWV2byB2YWxvciBBU0NJSVxyXG4gICAgICAgICAgICAgICAgICBjb250YWRvcisrO1xyXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoY29udGFkb3IgPiAxNjUpe1xyXG4gICAgICAgICAgICAgICAgICAvL0VuIGNhc28gZGUgcXVlIGVsIGNvbnRhZG9yIGhheWEgc3VwZXJhZG8gZWwgbMOtbWl0ZSBkZSBhc2lnbmFjaW9uZXNcclxuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGEgY2FudGlkYWQgZGUgY3VhZHJvcyBhIHN1cGVyYWRvIGVsIGxpbWl0ZSBlc3RhYmxlY2lkb1wiKTtcclxuICAgICAgICAgICAgICAgIH1lbHNlIHtcclxuICBcclxuICAgICAgICAgICAgICAgICAgLy9TaSBlbCBtYXBlbyByZWFsaXphZG8gZXMgZGUgdW4gbsO6bWVybyBkZSB1biBzw7NsbyBkaWdpdG8gZW50b25jZXMgYXNpZ25hbW9zIGRpcmVjdGFtZW50ZSBlc2UgbnVtZXJvIFxyXG4gICAgICAgICAgICAgICAgICAodGlsZU1hcFtudW1lcm9MYXllcl0pW3RpbGVOdW1iZXIudG9TdHJpbmcoKSBhcyBzdHJpbmddID0gdGlsZU51bWJlciBhcyBudW1iZXJcclxuICAgICAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgICB9ZWxzZXtcclxuICBcclxuICAgICAgICAgICAgICAgIC8vRW4gbGEgY2FzbyBkZSBleHRyYWVyIHVuIG7Dum1lcm8gcXVlIHlhIGhhIHNpZG8gbWFwZWFkbyB5IHlhIHRpZW5lIGFzaWduYWRvIHVuIHZhbG9yIEFTQ0lJXHJcbiAgICAgICAgICAgICAgICAvL0J1c2NhbW9zIGxhIGxsYXZlIGEgbGEgcXVlIGxlIGNvcnJlc3BvbmRlIGVzZSB2YWxvclxyXG4gICAgICAgICAgICAgICAgLy9ZIGFjdHVhbGl6YW1vcyBlbCBtYXBhIGNvbiBlc2UgY2FyYWN0ZXIgZW5jb250cmFkby5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUVuY29udHJhZGEgPSBPYmplY3QuZW50cmllcyh0aWxlTWFwW251bWVyb0xheWVyXSkuZmluZCgoW18sIHZhbHVlXSkgPT4gdmFsdWUgPT09IHRpbGVOdW1iZXIpPy5bMF07XHJcbiAgICAgICAgICAgICAgICB3b3JsZEpzb24ubGF5ZXJzW251bWVyb0xheWVyXS5kYXRhW2luZGV4XSA9IGtleUVuY29udHJhZGFcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gIFxyXG4gIFxyXG4gICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAvL2xldCB0YW1hw7FvQ3VhZHJvID0gd2luZG93LmlubmVyV2lkdGggLyAyMFxyXG4gICAgICAgICAgLy9sZXQgY3VhZHJvUG9zaWNpb24gPSB6b25hQ29saXNpb24ueCAvIDMyXHJcbiAgICAgICAgICBsZXQgcHJvcG9yY2lvblggPSAoIHdpbmRvdy5pbm5lcldpZHRoIC8gKDMyICogVElMRURfTUFQX19XSURUSF9OVU1CRVIpIClcclxuICAgICAgICAgIGxldCBwcm9wb3JjaW9uWSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLyAoMzIgKiBUSUxFRF9IRUlHVEhfTlVNQkVSKSlcclxuICBcclxuICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwib2JqZWN0Z3JvdXBcIiAmJiBsYXllci5uYW1lID09PSBcImNvbGlzaW9uZXNcIil7XHJcbiAgXHJcbiAgICAgICAgICAgIGxheWVyLm9iamVjdHMuZm9yRWFjaCggKHpvbmFDb2xpc2lvbjogYW55LCBudW1lcm9Db2xpc2lvbjogbnVtYmVyKSA9PiB7XHJcbiAgXHJcbiAgICAgICAgICAgICAgLy9pZihudW1lcm9Db2xpc2lvbiA9PT0gNCl7XHJcbiAgICAgICAgICAgICAgICAvLyBab25hIGRlIGNhaWRcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh6b25hQ29saXNpb24ud2lkdGgpXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGxldCBjYWlkYV8gPSBjb250ZXh0b0thcGxheS5hZGQoW1xyXG4gICAgICAgICAgICAgICAgY29udGV4dG9LYXBsYXkucG9zKCAoem9uYUNvbGlzaW9uLnggLyAzMikgKiggd2luZG93LmlubmVyV2lkdGggLyAyMCksIE1hdGguZmxvb3IoKHpvbmFDb2xpc2lvbi55IC8gMzIgKSood2luZG93LmlubmVySGVpZ2h0IC8gMTUpKSksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0b0thcGxheS5zY2FsZSgxKSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LmJvZHkoe2lzU3RhdGljOiB0cnVlfSksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0b0thcGxheS5hcmVhKHtzaGFwZTogbmV3IGNvbnRleHRvS2FwbGF5LlJlY3QoY29udGV4dG9LYXBsYXkudmVjMigwLjApLCAoem9uYUNvbGlzaW9uLndpZHRoIC8gMzIpICogKCB3aW5kb3cuaW5uZXJXaWR0aCAvIDIwKSAsIHpvbmFDb2xpc2lvbi5oZWlnaHQgKiBwcm9wb3JjaW9uWSkgLy8gUmVjdMOhbmd1bG8gbcOhcyBwZXF1ZcOxb1xyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICB7IHdpZHRoOiB6b25hQ29saXNpb24ud2lkdGggKiBwcm9wb3JjaW9uWCwgaGVpZ2h0OiB6b25hQ29saXNpb24uaGVpZ2h0ICogcHJvcG9yY2lvblkgfSwgLy8gQWdyZWdhIHByb3BpZWRhZGVzIG1hbnVhbG1lbnRlXHJcbiAgICAgICAgICAgICAgICAvL2BzcXVhcmUtJHtudW1lcm9Db2xpc2lvbn1gLFxyXG4gICAgICAgICAgICAgICAgXCJzcXVhcmUtY29saXNpb25cIlxyXG4gICAgICAgICAgICAgICAgXSk7XHJcbiAgXHJcbiAgICAgICAgICAgICAgLy99XHJcbiAgICAgICAgICAgICAgXHJcbiAgXHJcbiAgICAgICAgICAgIH0pO1xyXG4gIFxyXG4gIFxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYobGF5ZXIudHlwZSA9PT0gXCJvYmplY3Rncm91cFwiICYmIGxheWVyLm5hbWUgPT09IFwicGxheWVyXCIpe1xyXG4gIFxyXG4gICAgICAgICAgICAgIC8vIEp1Z2Fkb3JcclxuICAgICAgICAgICAgICBjb25zdCBwbGF5ZXIgPSBjb250ZXh0b0thcGxheS5hZGQoW1xyXG4gICAgICAgICAgICAgICAgY29udGV4dG9LYXBsYXkucG9zKChsYXllci5vYmplY3RzWzBdLnggLyAzMikgKiAoIHdpbmRvdy5pbm5lcldpZHRoIC8gMjApLChsYXllci5vYmplY3RzWzBdLnkgLyAzMikgKiAoIHdpbmRvdy5pbm5lckhlaWdodCAvIDE1KSksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0b0thcGxheS5zcHJpdGUoXCJrbmlnaHRcIiksXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0b0thcGxheS5zY2FsZSgxKSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LmhlYWx0aCgzKSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LmFyZWEoKSxcclxuICAgICAgICAgICAgICAgIFwicGxheWVyXCIsXHJcbiAgICAgICAgICAgICAgICB7IHo6IDEgfSAvLyBBc2VndXJhIHF1ZSBlbCBqdWdhZG9yIGVzdMOpIGVuIHVuYSBjYXBhIHN1cGVyaW9yXHJcbiAgICAgICAgICAgICAgXSk7XHJcblxyXG4gICAgICAgICAgICAgIHBsYXllci50YWcoXCJwbGF5ZXJcIilcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhwbGF5ZXIpXHJcblxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnRleHRvS2FwbGF5LmdldChcInBsYXllclwiKSlcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmKGxheWVyLnR5cGUgPT09IFwib2JqZWN0Z3JvdXBcIiAmJiBsYXllci5uYW1lID09PSBcImVuZW15XCIpe1xyXG4gIFxyXG4gICAgICAgICAgICAvLyBKdWdhZG9yXHJcbiAgICAgICAgICAgIC8vIEVuZW1pZ29cclxuICAgICAgICAgICAgY29uc3QgZW5lbXkgPSBjb250ZXh0b0thcGxheS5hZGQoW1xyXG4gICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LnBvcygobGF5ZXIub2JqZWN0c1swXS54IC8gMzIpICogKCB3aW5kb3cuaW5uZXJXaWR0aCAvIDIwKSwobGF5ZXIub2JqZWN0c1swXS55IC8gMzIpICogKCB3aW5kb3cuaW5uZXJIZWlnaHQgLyAxNSkpLFxyXG4gICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LnNwcml0ZShcImVuZW15XCIpLFxyXG4gICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LnNjYWxlKDAuOCksXHJcbiAgICAgICAgICAgICAgY29udGV4dG9LYXBsYXkuYXJlYShcclxuICAgICAgICAgICAgIC8vIGNvbnRleHRvS2FwbGF5LmFyZWEoe3NoYXBlOiBuZXcgY29udGV4dG9LYXBsYXkuUmVjdChjb250ZXh0b0thcGxheS52ZWMyKCA1MCw4MCksIDMyLCAzMiksIC8vIFJlY3TDoW5ndWxvIG3DoXMgcGVxdWXDsW9cclxuICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LmJvZHkoKSxcclxuICAgICAgICAgICAgICBcImVuZW15XCIsXHJcbiAgICAgICAgICAgICAgeyB6OiAxIH0gLy8gQXNlZ3VyYSBxdWUgZWwganVnYWRvciBlc3TDqSBlbiB1bmEgY2FwYSBzdXBlcmlvclxyXG4gICAgICAgICAgICBdKTtcclxuXHJcbiAgICAgICAgICAgIGVuZW15LnRhZyhcImVuZW15XCIpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBcclxuICAgICAgXHJcbiAgICAgICAgdHlwZSBUaWxlQ29tcG9uZW50ID0gUmV0dXJuVHlwZTx0eXBlb2YgY29udGV4dG9LYXBsYXkuc3ByaXRlPiB8IFJldHVyblR5cGU8dHlwZW9mIGNvbnRleHRvS2FwbGF5LnNjYWxlPjtcclxuICAgICAgICBjb25zdCB0aWxlTWFwcGluZzogUmVjb3JkPHN0cmluZywgKCkgPT4gVGlsZUNvbXBvbmVudFtdPltdID0gW11cclxuICBcclxuICAgICAgICAvL1VuYSB2ZXogcmVhbGl6YWRhIGxhIGFzaWduYWNpw7NuIGVudHJlIHZhbG9yZXMgQVNDSUkgeSB2YWxvcmVzIG7Dum1lcmljb3MgZGVsIG1hcGFcclxuICAgICAgICAvL0VzIG5lY2VzYXJpbyBhc2lnbmFyIGEgdW4gU1BSSVRFIGEgY2FkYSB1bm8gZGUgZXNvcyB2YWxvcmVzLCBwb3IgbG8gcXVlIHBhcmFcclxuICAgICAgICAvL2xvZ3JhcmxvIGhhY2Vtb3MgbG8gc2lndWllbnRlOlxyXG4gICAgICAgIHRpbGVNYXAuZm9yRWFjaCggKGxheWVyOiBhbnksIG51bWVyb0xheWVyOiBudW1iZXIpID0+IHtcclxuICBcclxuICAgICAgICAgIC8vUGFyYSBjYWRhIHZhbG9yIEFTQ0lJIGRlIGxhIGNhcGEgcXVlIHNlIGVzdMOhIGV2YWx1YWRvIGhhY2Vtb3MgbG8gc2lndWllbnRlXHJcbiAgICAgICAgICBPYmplY3Qua2V5cyhsYXllcikuZm9yRWFjaCgoa2V5OmFueSwgaW5kZXg6IG51bWJlcikgPT4ge1xyXG4gIFxyXG4gIFxyXG4gIFxyXG4gICAgICAgICAgICAvL1NpIGxhIGNhcGEgcXVlIGVzdGFtb3MgZXh0cmF5ZW5kbyBlcyBsYSBwcmltZXJhLCBleHRyYWVtb3MgZWwgdmFsb3IgbnVtZXJpY28gYXNvY2lhZG8gYWwgY29kaWdvIEFTQ0lJIG8gXCJrZXlcIlxyXG4gICAgICAgICAgICAvL0RlIGxvIGNvbnRyYXJpbywgc2kgZXMgdW5hIGNhcGEgc3VwZXJpb3IsIGRlYmVtb3MgcmVzdGFyIGVsIHB1bnRvIGRlIG9yaWdlbiBkZSBsYXMgaW1hZ2VuZXMgU1BSSVRFIHVzYWRhcyBwYXJhXHJcbiAgICAgICAgICAgIC8vaGFsbGFyIGxvcyBmcmFtZXMgb3JpZ2luYWxlcy5cclxuICBcclxuICAgICAgICAgICAgY29uc3QgZnJhbWUgPSAobnVtZXJvTGF5ZXIgPT09IDAgKSA/IGxheWVyW2tleV0gOiAobGF5ZXJba2V5XSAhPT0gMCAmJiBsYXllcltrZXldICE9PSBcIjBcIiApICA/IGxheWVyW2tleV0gLSB0aWxlc2V0T3JkZXJbbnVtZXJvTGF5ZXJdLmZpcnN0Z2lkICsgMSA6IDA7IC8vIE9idGVuZXIgZWwgZnJhbWUgY29ycmVjdG8gZGVsIHRpbGVNYXBcclxuICBcclxuICAgICAgICAgICAgLy8gQXNlZ3VyYXIgcXVlIHRpbGVNYXBwaW5nW2luZGV4XSBleGlzdGUgY29tbyB1biBvYmpldG8gYW50ZXMgZGUgYXNpZ25hciB2YWxvcmVzXHJcbiAgICAgICAgICAgIGlmICghdGlsZU1hcHBpbmdbbnVtZXJvTGF5ZXJdKSB7XHJcbiAgICAgICAgICAgICAgdGlsZU1hcHBpbmdbbnVtZXJvTGF5ZXJdID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgLy9TaSBsYSBjbGF2ZSBxdWUgc2UgZXN0w6EgZXZhbHVhbmRvIG5vIGVzIGNlcm8sIGVudG9uY2VzIHF1aWVyZSBkZWNpciBxdWUgdGllbmUgdW4gc3ByaXRlIGFzb2NpYWRvIHkgbm8gZXMgdmFjaW9cclxuICAgICAgICAgICAgLy9Qb3IgbG8gcXVlIGhhY2Vtb3MgbG8gc2lndWllbnRlXHJcbiAgICAgICAgICAgIGlmKGtleSAhPT0gMCAmJiBrZXkgIT09IFwiMFwiICl7XHJcbiAgXHJcbiAgICAgICAgICAgICAgLy9BbCBUaWxlTWFwcGluZyAoTWFwYSBlbnRyZSBjb2RpZ28gQVNDSUkgeSBlbCBTUFJJVEUgbGUgYXNpZ25hbW9zIGVsIGZyYW1lIGVuY29udHJhZG8gKG1lbm9zIHVuYSBwb3NpY2lvbiBwb3JxdWUgVElMRUQgZW1waWV6YSBlbiAxKSlcclxuICAgICAgICAgICAgICAgdGlsZU1hcHBpbmdbbnVtZXJvTGF5ZXJdW2tleV0gPSAoKSA9PiBbXHJcbiAgICAgICAgICAgICAgICBjb250ZXh0b0thcGxheS5zcHJpdGUoYHRpbGVzLSR7bnVtZXJvTGF5ZXIrMX1gLCB7IGZyYW1lOiAoZnJhbWUgYXMgbnVtYmVyKSAtIDEsIHdpZHRoOiBhbmNob0N1YWRyYWRvLCBoZWlnaHQ6IGFsdG9DdWFkcmFkbyB9KSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LnNjYWxlKDEpXHJcbiAgICAgICAgICAgICAgIF1cclxuICBcclxuICAgICAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICAgICAgLy9EZSBsbyBjb250cmFyaW8gc2kgZW5jdWVudHJhIHVuIGNlcm8sIGxlIGFzaWduYW1vcyB1bmEgaW1hZ2VuIGVzcGVjaWFsIHRyYW5zcGFyZW50ZSBwYXJhIGN1YnJpciBlbCBlc3BhY2lvIHZhY2lvXHJcbiAgICAgICAgICAgICAgKHRpbGVNYXBwaW5nW251bWVyb0xheWVyXSlba2V5XSA9ICgpID0+IFtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LnNwcml0ZShgdGl0bGUtMGAsIHsgd2lkdGg6IGFuY2hvQ3VhZHJhZG8sIGhlaWdodDogYWx0b0N1YWRyYWRvIH0pXHJcbiAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICBcclxuICAgICAgICAgIH0pO1xyXG4gIFxyXG4gICAgICAgIH0pXHJcbiAgICAgIFxyXG4gICAgICAgIFxyXG4gIFxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgd29ybGRKc29uLmxheWVycy5mb3JFYWNoKChsYXllcjogYW55LCBudW1lcm9MYXllcjogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgXHJcbiAgICAgICAgICBsZXQgcmVzdWx0YWRvTWFwYSA9IFtdO1xyXG4gICAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09IFwidGlsZWxheWVyXCIgKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YSwgd2lkdGggfSA9IGxheWVyO1xyXG4gICAgICAgICAgICBjb25zdCBtYXBhID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIG1hcGEucHVzaChkYXRhLnNsaWNlKGkgKiB3aWR0aCwgKGkgKyAxKSAqIHdpZHRoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0YWRvTWFwZW8gPSBtYXBhLm1hcCgoZmlsYTogYW55KSA9PlxyXG4gICAgICAgICAgICAgIGZpbGEubWFwKChjZWxsOiBhbnkpID0+IGNlbGwudG9TdHJpbmcoKSkuam9pbihcIlwiKVxyXG4gICAgICAgICAgICApO1xyXG4gIFxyXG4gICAgICAgICAgICByZXN1bHRhZG9NYXBhID0gWy4uLnJlc3VsdGFkb01hcGVvXVxyXG4gIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnRleHRvS2FwbGF5LmFkZExldmVsKHJlc3VsdGFkb01hcGEsIHtcclxuICAgICAgICAgICAgICB0aWxlV2lkdGg6IGFuY2hvQ3VhZHJhZG8sXHJcbiAgICAgICAgICAgICAgdGlsZUhlaWdodDogYWx0b0N1YWRyYWRvLFxyXG4gICAgICAgICAgICAgIHBvczogY29uZmlndXJhY2lvbk1hcGEucG9zLFxyXG4gICAgICAgICAgICAgIHRpbGVzOiB7IC4uLnRpbGVNYXBwaW5nW251bWVyb0xheWVyXSB9LFxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgfVxyXG4gIFxyXG4gIFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBcclxuICAgICAgICB9KVxyXG4gICAgICAgICovXHJcbiAgXHJcbiAgICAgIH1cclxuICBcclxuICAgICAgXHJcbiAgICApXHJcbiAgICAuY2F0Y2goIChlcnJvcjogYW55KSA9PiB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpXHJcbiAgICB9KTtcclxuICBcclxuICAgIFxyXG4gICAgfVxyXG5cclxuICAgIGV4cG9ydCBkZWZhdWx0IGdlbmVyYXJFc3F1ZW1hTWFwYTtcclxuXHJcblxyXG5cclxuXHJcbiAgICBcclxuXHJcblxyXG4iXSwibmFtZXMiOlsiZGV2b2x2ZXJTaWd1aWVudGVOdW1lcm9WYWxpZG8iLCJUSUxFRF9XSURUSF9OVU1CRVIiLCJUSUxFRF9IRUlHVEhfTlVNQkVSIiwiU0NSRUVOX1JFU09MVVRJT05fWCIsIndpbmRvdyIsImlubmVyV2lkdGgiLCJTQ1JFRU5fUkVTT0xVVElPTl9ZIiwiaW5uZXJIZWlnaHQiLCJUSUxFRF9NQVBfX1dJRFRIX05VTUJFUiIsIlRJTEVEX01BUF9IRUlHSFRfTlVNQkVSIiwiZ2VuZXJhckVzcXVlbWFNYXBhIiwiY29udGV4dG9LYXBsYXkiLCJjb25maWd1cmFjaW9uTWFwYSIsInVybE1hcGEiLCJpbmZvcm1hY2lvbk1hcGEiLCJmZXRjaCIsInRoZW4iLCJyZXMiLCJqc29uIiwid29ybGRKc29uIiwiY29uc29sZSIsImxvZyIsImdldCIsImxvYWRTcHJpdGUiLCJuYW1lRm9sZGVyIiwibmFtZUZpbGUiLCJzbGljZVgiLCJzbGljZVkiLCJvbkRyYXciLCJkcmF3U3ByaXRlIiwic3ByaXRlIiwid2lkdGgiLCJoZWlnaHQiLCJ0aWxlc2V0T3JkZXIiLCJzcHJpdGVzQ2FyZ2Fkb3MiLCJmb3JFYWNoIiwiaW5mb3JtYWNpb25OaXZlbCIsImluZGV4IiwicHVzaCIsInVybFRleHR1cmEiLCJkaW1lbnNpb25UZXh0dXJhc1giLCJkaW1lbnNpb25UZXh0dXJhc1kiLCJhbmNob0N1YWRyYWRvIiwiYWx0b0N1YWRyYWRvIiwidGlsZU1hcCIsInZhbG9yZXNQcm9oaWJpZG9zIiwibWFwYUdlbmVyYWRvIiwibGF5ZXJzIiwibGF5ZXIiLCJudW1lcm9MYXllciIsImNvbnRhZG9yIiwidHlwZSIsImRhdGEiLCJ0aWxlTnVtYmVyIiwibGVuZ3RoIiwiT2JqZWN0IiwidmFsdWVzIiwiaW5jbHVkZXMiLCJ0b1N0cmluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIkVycm9yIiwia2V5RW5jb250cmFkYSIsImVudHJpZXMiLCJmaW5kIiwiXyIsInZhbHVlIiwicHJvcG9yY2lvblgiLCJwcm9wb3JjaW9uWSIsIm5hbWUiLCJvYmplY3RzIiwiem9uYUNvbGlzaW9uIiwibnVtZXJvQ29saXNpb24iLCJjYWlkYV8iLCJhZGQiLCJwb3MiLCJ4IiwiTWF0aCIsImZsb29yIiwieSIsInNjYWxlIiwiYm9keSIsImlzU3RhdGljIiwiYXJlYSIsInNoYXBlIiwiUmVjdCIsInZlYzIiLCJwbGF5ZXIiLCJoZWFsdGgiLCJ6IiwidGFnIiwiZW5lbXkiLCJ0aWxlTWFwcGluZyIsImtleXMiLCJrZXkiLCJmcmFtZSIsImZpcnN0Z2lkIiwiY2F0Y2giLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/MapsGenerator.tsx\n"));

/***/ })

});